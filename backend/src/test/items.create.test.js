const request = require("supertest");
const express = require("express");
const itemsRouter = require("../routes/items"); // Path to your actual routes file
const fs = require("fs").promises; // Import the promise-based fs
const { mockItems } = require("./mockData"); // Import mock data

// --- Mock fs.promises for file operations ---
jest.mock("fs", () => ({
  promises: {
    readFile: jest.fn(),
    writeFile: jest.fn(),
  },
}));

// Declare mockedFsPromises to be assigned in beforeEach
let mockedFsPromises;

// Helper function to create a minimal Express app for testing
const createApp = () => {
  const app = express();
  app.use(express.json()); // Essential for POST requests to parse req.body
  app.use("/api/items", itemsRouter); // Mount your items router

  // Generic error handling middleware for tests
  app.use((err, req, res, next) => {
    res
      .status(err.status || 500)
      .json({ message: err.message || "Internal Server Error" });
  });

  return app;
};

let app;

// Before each test, re-initialize the app and reset mocks
beforeEach(() => {
  app = createApp();
  jest.clearAllMocks(); // Resets all mocks, including readFile and writeFile

  // CRITICAL: Get the mocked fs.promises here
  mockedFsPromises = require("fs").promises;

  // Default mock implementation for readFile for all tests in this file
  // POST needs to read existing data before adding new data
  mockedFsPromises.readFile.mockResolvedValue(JSON.stringify(mockItems));
  // Default mock implementation for writeFile
  mockedFsPromises.writeFile.mockResolvedValue(undefined); // undefined signifies success
});

// --- Test Suite for POST /api/items ---

describe("POST /api/items", () => {
  const newItemPayload = {
    name: "Smart Watch",
    price: 250,
    description: "A cool smart watch",
  };

  // HAPPY PATH
  test("should create a new item, return 201 status, and write updated data", async () => {
    const res = await request(app).post("/api/items").send(newItemPayload); // Send the new item data

    expect(res.statusCode).toEqual(201); // Expect HTTP 201 Created

    // Verify the response body contains the newly created item with an ID
    expect(res.body).toHaveProperty("id");
    expect(res.body.name).toEqual(newItemPayload.name);
    expect(res.body.price).toEqual(newItemPayload.price);
    // You can also check if the ID is a number and roughly around Date.now()
    expect(typeof res.body.id).toBe("number");
    expect(res.body.id).toBeGreaterThan(Date.now() - 1000); // ID should be a recent timestamp

    // Verify readFile was called once to get existing items
    expect(mockedFsPromises.readFile).toHaveBeenCalledTimes(1);

    // Verify writeFile was called once with the updated data
    expect(mockedFsPromises.writeFile).toHaveBeenCalledTimes(1);

    // Get the arguments writeFile was called with
    const writtenFilePath = mockedFsPromises.writeFile.mock.calls[0][0]; // First argument: path
    const writtenDataString = mockedFsPromises.writeFile.mock.calls[0][1]; // Second argument: data string

    

    // Parse the written JSON string to verify content
    const writtenItems = JSON.parse(writtenDataString);

    // Expect the total number of items to increase by one
    expect(writtenItems.length).toEqual(mockItems.length + 1);

    // Expect the new item (with its generated ID) to be present in the written data
    // We use expect.objectContaining because we don't know the exact ID generated by Date.now()
    expect(writtenItems).toContainEqual(
      expect.objectContaining({
        name: newItemPayload.name,
        price: newItemPayload.price,
        id: res.body.id, // The ID returned in the response should be in the written data
      })
    );
  });

  // ERROR CASES

  test("should handle file read error during POST operation", async () => {
    // Mock readFile to reject when the route tries to read existing data
    mockedFsPromises.readFile.mockRejectedValueOnce(
      new Error("Read error during POST before save")
    );

    const res = await request(app).post("/api/items").send(newItemPayload);

    expect(res.statusCode).toEqual(500); // Expect server error
    expect(res.body.message).toEqual("Read error during POST before save");
    expect(mockedFsPromises.readFile).toHaveBeenCalledTimes(1);
    expect(mockedFsPromises.writeFile).not.toHaveBeenCalled(); // Ensure no write happened if read failed
  });

  test("should handle file write error during POST operation", async () => {
    // Mock readFile to succeed (to get existing items)
    mockedFsPromises.readFile.mockResolvedValueOnce(JSON.stringify(mockItems));
    // Mock writeFile to reject when the route tries to save the new data
    mockedFsPromises.writeFile.mockRejectedValueOnce(
      new Error("Write error during POST after adding item")
    );

    const res = await request(app).post("/api/items").send(newItemPayload);

    expect(res.statusCode).toEqual(500); // Expect server error
    expect(res.body.message).toEqual(
      "Write error during POST after adding item"
    );
    expect(mockedFsPromises.readFile).toHaveBeenCalledTimes(1);
    expect(mockedFsPromises.writeFile).toHaveBeenCalledTimes(1); // writeFile was attempted
  });

  test("should handle invalid JSON data in file when reading existing items for POST", async () => {
    // Mock readFile to return malformed JSON for the initial read
    mockedFsPromises.readFile.mockResolvedValueOnce('{"id":1, "name":"Test"');

    const res = await request(app).post("/api/items").send(newItemPayload);

    expect(res.statusCode).toEqual(500);
    expect(res.body.message).toMatch(/Unexpected|JSON/); // Expect JSON parsing error
    expect(mockedFsPromises.readFile).toHaveBeenCalledTimes(1);
    expect(mockedFsPromises.writeFile).not.toHaveBeenCalled(); // No write should happen
  });

  // Optional: Test for missing/malformed payload if validation were present
  // As per your TODO, validation is omitted, so we don't test invalid payload structures for now.
});
